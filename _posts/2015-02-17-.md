---
layout: post
title: "函数式编程"
description: ""
category: 
tags: []
---

摘要：函数式编程因其生成错误少且产能高而受到越来越多的关注，本文详尽阐述了函数式编程（Functional Programming，FP）范式的编程思想，通过类比，比较了FP 和指令式编程的异同。指出了FP 相对于指令式编程的优点，讨论了FP 在现代编程语言中的应用和今后的一些研究方向。


20世纪30年代，阿隆佐·邱奇和艾伦·图灵、约翰·冯·诺伊曼设计了一个名为lambda演算的形式系统，这个系统实质上是为一个超级机器设计的编程语言。在这种语言里面，函数的参数是函数，返回值也是函数。函数式编程是阿隆佐思想的在现实世界中的实现。不过不是全部的lambda演算思想都可以运用到实际中，因为lambda演算在设计的时候就不是为了在各种现实世界中的限制下工作的。所以，就像面向对象的编程思想一样，函数式编程只是一系列想法，而不是一套严苛的规定。这些想法包括函数是第一等公民、不修改状态、只用表达式不用语句和引用透明等等。这四个鲜明的特性形成了函数式编程的准则：不依赖外部的数据，而且也不修改外部的数据的值，而是返回一个新的值。这样所有的函数都不会有副作用，方便单元测试和调试查错，也有利于解耦、复用和并发，所以函数式编程能极大的减少错误以及提高产能。

### 1 函数式编程概述

"函数式编程"是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论。
它属于"结构化编程"的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。举例来说，现在有这样一个数学表达式：

    (1 + 2) * 3 - 4

传统的指令式编程，可以这样写：

    var a = 1 + 2;
    var b = a * 3;
    var c = b - 4;

函数式编程要求使用函数，我们可以把运算过程定义为不同的函数，然后写成下面这样：

    var result = subtract(multiply(add(1,2), 3), 4);

### 2 函数式编程的特性

#### 2.1 函数是第一等公民

所谓"第一等公民"（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。
举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。

    var print = function(i){ console.log(i);};
    [1,2,3].forEach(print);

#### 2.2 只用表达式，不用语句

"表达式"（expression）是一个单纯的运算过程，总是有返回值；"语句"（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。
原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。"语句"属于对系统的读写操作，所以就被排斥在外。
当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。

#### 2.3 不修改状态

上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。
在其他类型的语言中，变量往往用来保存"状态"（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的"状态"。

    var reverse = function (str) {
    　　if(str.length == 0) {
    　　　　return str;
    　　} else {
    　　　　return reverse(str.substring(1, str.length)) + str.substring(0, 1);
    　　}
    };


#### 2.4 引用透明

引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。
有了前面的第二点和第三点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫"引用不透明"，很不利于观察和理解程序的行为。

### 3 函数式编程的优点

#### 3.1 单元测试和调试查错

通常理解的变量在函数式编程中也被函数代替了，变量仅仅代表某个表达式，那么在程序运行时就不能修改任何变量，也没有地方可以修改全局变量。这意味着函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。在测试的时候只需要关注传递的参数就可以了，完全不用担心函数调用时的顺序，也不用费心设置外部状态值，唯一需要做的就是传递一些可以代表边界条件的参数。反观指令式编程，仅仅检查函数的返回值是不够的，代码可以修改外部状态值，因此还需要检查这些外部状态值的正确性。
FP 代码的调试工作也很简单，因为这些错误是可以百分之一百重现的，因为 FP 程序中的错误不依赖之前运行过的代码、而在指令式编程中，由于函数的运行依赖外部变量，这样可能会导致一个 bug 有时复现而有时候又不能。另外，对指令式程序中函数返回值的检查并不能保证这个函数是正确运行的。还要逐一检查若干作用域以外的对象以确保这个函数没有对这些牵连的对象做出什么越轨的行为。对于一个FP程序，你要做的仅仅是看一下函数的返回值。

#### 3.2 并发执行

不需要任何改动，所有FP程序都是可以并发执行的。由于根本不需要采用锁机制，因此完全不需要担心死锁或是并发竞争的发生。在FP程序中没有哪个线程可以修改任何数据，更不用说多线程之间了。
既然是这样，为什么没有人在那些高度并行的那些应用程序中采用FP编程呢？事实上，这样的例子并不少见。爱立信开发了一种FP语言，名叫Erlang，并应用在他们的电信交换机上，而这些交换机不仅容错度高而且拓展性强。FP 关于并行的优势不仅于此。就算某个FP 程序本身只是单线程的，编译器也可以将其优化成可以在多CPU 上运行的并发程序。以下面的程序为例：

    var s1 = somewhatLongOperation1();
    var s2 = somewhatLongOperation2();
    var s3 = concat(s1, s2);

如果是函数式程序，编译器就可以对代码进行分析，然后可能分析出生成字符串s1和s2的两个函数可能会比较耗时，进而安排它们并行运行。这在指令式编程中是无法做到的，因为每一个函数都有可能修改其外部状态，然后接下来的函数又可能依赖于这些状态的值。在函数式编程中，自动分析代码并找到适合并行执行的函数十分简单，和分析C的内联函数一致。硬件厂商已经没办法让CPU运行得再快了。他们只能靠增加CPU核的数量然后用并行来提高运算的速度。这些厂商故意忽略一个事实：只有可以并行的软件才能让你花大价钱买来的这些硬件物有所值。指令式的软件中只有很小一部分能做到跨核运行，而所有的函数式软件都能实现这一目标，因为FP 的程序从一开始就是可以并行运行的。

#### 3.3 机器辅助优化及证明

FP语言有一个特性很有意思，那就是它们是可以用数学方法来分析的。FP语言本身就是形式系统的实现，只要是能在纸上写出来的数学运算就可以用这种语言表述出来。于是只要能够用数学方法证明两段代码是一致的，编译器就可以把某段代码解析成在数学上等同的但效率又更高的另外一段代码。 关系数据库已经用这种方法进行优化很多年了，同理在常规的软件行业就不能应用这种技术。另外，还可以用这种方法来证明代码的正确性，甚至可以设计出能够自动分析代码并为单元测试自动生成边缘测试用例的工具出来！对于那些对缺陷零容忍的系统来说，这一功能简直就是无价之宝。例如心脏起搏器，例如飞行管控系统，这几乎就是必须满足的需求。

#### 3.4 惰性求值

惰性求值（或是延迟求值）是一种有趣的技术，而当我们投入函数式编程的怀抱后这种技术就有了得以实现的可能。前面介绍并发执行的时候已经提到过如下代码：

    var s1 = somewhatLongOperation1();
    var s2 = somewhatLongOperation2();
    var s3 = concat(s1, s2);

在指令式语言中以上代码执行的顺序是显而易见的。由于每个函数都有可能改动或者依赖于其外部的状态，因此必须顺序执行。先是计算somewhatLongOperation1，然后到somewhatLongOperation2，最后执行concat。函数式语言就不一样了。
在前面讨论过，somewhatLongOperation1和somewhatLongOperation2是可以并发执行的，因为函数式语言保证了一点：没有函数会影响或者依赖于全局状态。可是万一我们不想要这两个函数并发执行呢？这种情况下是不是也还是要顺序执行这些函数？答案是否定的。只有到了执行需要s1、s2作为参数的函数的时候，才真正需要执行这两个函数。于是在concat这个函数没有执行之前，都没有需要去执行这两个函数：这些函数的执行可以一直推迟到concat()中需要用到s1和s2的时候。假如把concat换成另外一个函数，这个函数中有条件判断语句而且实际上只会需要两个参数中的其中一个，那么就完全没有必要执行计算另外一个参数的函数了！

#### 3.4 代码优化

惰性求值使得代码具备了巨大的优化潜能。支持惰性求值的编译器会像数学家看待代数表达式那样看待函数式程序：抵消相同项从而避免执行无谓的代码，安排代码执行顺序从而实现更高的执行效率甚至是减少错误。在此基础上优化是不会破坏代码正常运行的。严格使用形式系统的基本元素进行编程带来的最大的好处，是可以用数学方法分析处理代码，因为这样的程序是完全符合数学法则的。

#### 3.5 无穷数据结构

惰性求值技术允许定义无穷数据结构，这要在严格语言中实现将非常复杂。例如一个储存Fibonacci数列数字的列表。很明显这样一个列表是无法在有限的时间内计算出这个无穷的数列并存储在内存中的。在像Java这样的严格语言中，可以定义一个Fibonacci函数，返回这个序列中的某个数。而在Haskell或是类似的语言中，可以把这个函数进一步抽象化并定义一个Fibonacci数列的无穷列表结构。由于语言本身支持惰性求值，这个列表中只有真正会被用到的数才会被计算出来。这让我们可以把很多问题抽象化，然后在更高的层面上解决它们（比如可以在一个列表处理函数中处理无穷多数据的列表）。


### 4 结论

函数式编程使用参数保存状态，最好的例子就是递归。FP 中大量使用了递归，递归最大的好处就简化代码，他可以把一个复杂的问题用很简单的代码描述出来。其实递归的精髓是描述问题，而这正是函数式编程的精髓。递归的害处，那就是如果递归很深的话，导致堆栈开销很大，并会导致性能大幅度下降。

惰性求值技术提供了更高阶的抽象能力，这提供了实现程序设计独特的方法。同时也面临了一个问题，现实生活中还是有很多问题需要严格求值的，特别是 I/O和调用系统函数（这些函数需要按顺序执行，因为他们依赖外注状态），也就是说不能和外界交互了！如果在代码中引入支持顺序执行的代码原语，那么我们就失去了用数学方式分析处理代码的优势（而这也意味着失去了函数式编程的所有优势）。

通过以上的讨论和研究，可以确定今后的研究方向，主要包括以下两点：

- 在递归时，如何减少堆栈开销，提高性能，这需要在语言和编译器方面做很多工作。
- 如何保证代码按一定的顺序执行，同时利用到函数式和指令式编程的优点。

参考文献：
[1]叶俊 谭庆平 李暾,2010.面向特征编程范式的形式化验证技术研究综述.计算机工程与科学,9:89
[2]杨路,1998.不等式机器证明的降维算法与通用程序.高技术通讯,7:20
[3]王明文 孙永强,2001.对象式Lambda演算的自作用部分计值.软件学报,8:1154
[4]Paul Graham,阮一峰译,2011.黑客与画家.人民邮电出版社,149
[5]SL Peyton Jones,1987.The Implementation of Functional Programming Languages (Prentice-Hall International Series in Computer Science).Prentice-Hall,9

{% include JB/setup %}
